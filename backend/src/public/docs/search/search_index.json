{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Thread Agent Documentation","text":"<p>Welcome to the Thread Agent documentation. This is a FastAPI-based application that integrates LangGraph for building sophisticated chatbot interactions.</p>"},{"location":"index.html#overview","title":"Overview","text":"<p>The Thread Agent is a powerful chatbot application that: - Processes and responds to user inputs using LangGraph and LangChain - Supports multiple language models (Claude 3.5 Sonnet and GPT-4) - Provides document management and vector storage capabilities - Includes tools for shell commands and Docker operations</p>"},{"location":"index.html#quick-start","title":"Quick Start","text":""},{"location":"index.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>Access to OpenAI API or Anthropic API</li> <li>Docker and Docker Compose (for full functionality)</li> </ul>"},{"location":"index.html#api-reference","title":"API Reference","text":"<p>The API documentation is available at <code>/api</code> when running the application. This includes: - Complete endpoint documentation - Request/response examples - Authentication requirements</p>"},{"location":"index.html#installation","title":"Installation","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/ryaneggz/langgraph-template.git\ncd langgraph-template\n</code></pre> <ol> <li>Set up your virtual environment:</li> </ol> <pre><code>## Install uv if do not have\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n## Start venv\nuv venv\n\n## Activate\nsource .venv/bin/activate\n\n## Install\nuv pip install -r requirements.txt\n</code></pre>"},{"location":"index.html#core-features","title":"Core Features","text":""},{"location":"index.html#document-management","title":"Document Management","text":"<p>The application provides comprehensive document management capabilities through the following endpoints:</p>"},{"location":"index.html#available-tools","title":"Available Tools","text":"<p>The system includes various tools for: - Shell command execution - Docker container management - File processing and document handling</p> <p>For detailed information about available tools, see the Tools Documentation.</p>"},{"location":"index.html#deployment","title":"Deployment","text":"<p>The application can be deployed using: - Docker Compose for local development - DigitalOcean for production deployment</p> <p>For detailed deployment instructions, see the Deployment Guide.</p>"},{"location":"index.html#configuration","title":"Configuration","text":"<p>Environment variables can be configured through <code>.env</code> files: - <code>.env</code> for local development - <code>.env.production</code> for production settings</p>"},{"location":"index.html#contributing","title":"Contributing","text":"<p>For contribution guidelines and development setup, please refer to our GitHub repository.</p>"},{"location":"deploy/aws-rds.html","title":"Setting up AWS RDS Database","text":"<p>This guide will walk you through setting up a PostgreSQL database using Amazon RDS.</p>"},{"location":"deploy/aws-rds.html#prerequisites","title":"Prerequisites","text":"<ul> <li>AWS Account with appropriate permissions</li> <li>AWS CLI installed (optional)</li> <li>Basic understanding of AWS services</li> </ul>"},{"location":"deploy/aws-rds.html#creating-an-rds-instance","title":"Creating an RDS Instance","text":"<ol> <li>Navigate to the RDS Dashboard:</li> <li>Log into AWS Console</li> <li> <p>Search for \"RDS\" or find it under Services</p> </li> <li> <p>Create a new database:</p> </li> <li>Click \"Create database\"</li> <li>Choose \"Standard create\"</li> <li> <p>Select PostgreSQL as the engine type</p> </li> <li> <p>Configure basic settings:    <pre><code>Instance configuration:\n- DB instance identifier: your-app-db\n- Master username: postgres (or your preferred username)\n- Master password: (create a strong password)\n\nInstance specifications:\n- DB instance class: db.t3.micro (for development)\n- Storage: 20 GB (minimum)\n</code></pre></p> </li> <li> <p>Configure network settings:    <pre><code>Network settings:\n- VPC: Choose your VPC\n- Public access: Yes (for development only)\n- VPC security group: Create new or select existing\n</code></pre></p> </li> <li> <p>Configure security group:</p> </li> <li>Create a new security group or modify existing</li> <li>Add inbound rule for PostgreSQL (port 5432)</li> <li>Limit source IP to your application's IP</li> </ol>"},{"location":"deploy/aws-rds.html#connection-information","title":"Connection Information","text":"<p>After your RDS instance is created, you'll need these details for your application: </p> <pre><code>Host: your-db-instance.xxxxx.region.rds.amazonaws.com\nPort: 5432\nDatabase: postgres (or your database name)\nUsername: (your master username)\nPassword: (your master password)\n</code></pre>"},{"location":"deploy/aws-rds.html#security-considerations","title":"Security Considerations","text":"<ul> <li>Never commit database credentials to version control</li> <li>Use environment variables for sensitive information</li> <li>In production:</li> <li>Disable public access</li> <li>Use AWS Secrets Manager for credentials</li> <li>Implement proper VPC and security group rules</li> </ul>"},{"location":"deploy/aws-rds.html#connection-string-format","title":"Connection String Format","text":"<p>For most applications, your connection string will look like this:</p> <pre><code>postgresql://username:password@your-db-instance.xxxxx.region.rds.amazonaws.com:5432/database_name\n</code></pre>"},{"location":"deploy/aws-rds.html#cost-considerations","title":"Cost Considerations","text":"<ul> <li>RDS instances incur charges even when idle</li> <li>Consider stopping instances when not in use</li> <li>Monitor usage and costs regularly</li> <li>Use reserved instances for production workloads</li> </ul>"},{"location":"deploy/aws-rds.html#best-practices","title":"Best Practices","text":"<ol> <li>Regular backups (automated by RDS)</li> <li>Monitor performance metrics</li> <li>Use parameter groups for database configuration</li> <li>Implement proper security measures</li> <li>Use Multi-AZ deployment for production</li> </ol>"},{"location":"deploy/aws-rds.html#cleanup","title":"Cleanup","text":"<p>To avoid unnecessary charges: 1. Take final backup if needed 2. Delete the RDS instance 3. Delete associated security groups 4. Remove unused subnet groups</p>"},{"location":"deploy/digitalocean.html","title":"Deploying to DigitalOcean","text":"<p>This guide walks you through deploying the application to DigitalOcean using Terraform.</p>"},{"location":"deploy/digitalocean.html#prerequisites","title":"Prerequisites","text":"<ol> <li>Install Terraform</li> <li>Get your DigitalOcean API token</li> <li>Go to DigitalOcean Cloud Control Panel</li> <li>Navigate to API \u2192 Generate New Token</li> <li> <p>Create a token with both read and write access</p> </li> <li> <p>Create Slack App</p> </li> <li>Go to Slack API Apps page</li> <li>Click \"Create New App\" and choose \"From scratch\"</li> <li>Name your app and select your workspace</li> <li>Under \"OAuth &amp; Permissions\":<ul> <li>Add Bot Token Scopes:</li> <li><code>app_mentions:read</code></li> <li><code>chat:write</code></li> <li><code>im:history</code> </li> <li><code>im:read</code></li> <li><code>im:write</code></li> </ul> </li> <li>Under \"Socket Mode\":<ul> <li>Enable Socket Mode</li> <li>Generate and save your App-Level Token</li> </ul> </li> <li>Install the app to your workspace</li> <li> <p>Save both the Bot User OAuth Token and App-Level Token for deployment</p> </li> <li> <p>Gather required API keys:</p> </li> <li>Anthropic API key</li> <li>OpenAI API key</li> <li>Slack Bot Token</li> <li>Slack App Token</li> </ol>"},{"location":"deploy/digitalocean.html#deployment-steps","title":"Deployment Steps","text":"<ol> <li> <p>Navigate to the terraform directory:    <pre><code>cd deployment/terraform/digitalocean\n</code></pre></p> </li> <li> <p>Run the deployment script:    <pre><code>bash ./deploy.sh\n</code></pre></p> </li> <li> <p>The script will prompt you for:</p> </li> <li>DigitalOcean API token</li> <li>Project name</li> <li>Region selection</li> <li>Droplet size</li> <li>API keys (Anthropic, OpenAI)</li> <li>Slack tokens</li> <li>App version tag</li> <li> <p>App credentials</p> </li> <li> <p>Review the deployment plan and confirm to proceed</p> </li> <li> <p>After deployment completes, the script will:</p> </li> <li>Save server passwords to <code>.terraform.serveradmin_password</code> and <code>.terraform.aiuser_password</code></li> <li>Display SSH connection commands</li> <li>Show the status page URL</li> </ol>"},{"location":"deploy/digitalocean.html#accessing-your-deployment","title":"Accessing Your Deployment","text":"<ul> <li>Status Page: <code>http://&lt;droplet-ip&gt;:8080</code></li> <li>API Endpoint: <code>http://&lt;droplet-ip&gt;:8000</code></li> <li>Database Admin: <code>http://&lt;droplet-ip&gt;:4040</code></li> </ul>"},{"location":"deploy/digitalocean.html#ssh-access","title":"SSH Access","text":"<pre><code>## Admin Access\nssh aiuser@&lt;droplet-ip&gt;\n</code></pre>"},{"location":"deploy/digitalocean.html#monitoring","title":"Monitoring","text":"<ol> <li>Connect to the server via SSH</li> <li> <p>View application logs:    <pre><code>tmux attach -t agent_api\n</code></pre>    (Use <code>Ctrl+B, D</code> to detach from tmux)</p> </li> <li> <p>View Docker containers:    <pre><code>docker ps\n</code></pre></p> </li> </ol>"},{"location":"deploy/digitalocean.html#configuration-storage","title":"Configuration Storage","text":"<p>Your deployment configuration is saved in <code>.terraform.config.json</code> for future deployments. This includes: - Region selection - Droplet size - API keys - Project settings</p> <p>Note: Keep your <code>.terraform.config.json</code> and password files secure as they contain sensitive information.</p>"},{"location":"tools/shell_docker.html","title":"Shell Docker","text":""},{"location":"tools/shell_docker.html#shell_docker","title":"shell_docker","text":"<p>The <code>shell_docker</code> is a function that allows running shell commands inside a Docker container. It accepts a list of strings, where each string represents a command to be executed in the container.</p>"},{"location":"tools/shell_docker.html#parameters","title":"Parameters","text":"<ul> <li><code>commands</code>: A list of strings, each representing a shell command to be executed in the Docker container.</li> </ul>"},{"location":"tools/shell_docker.html#usage","title":"Usage","text":"<pre><code>@tool\ndef shell_docker(commands: list[str]):\n    \"\"\"Run shell commands in a Docker container. Accepts multiple commands as a list of strings. \n    Each command is executed sequentially inside the specified container. Avoid interactive commands.\"\"\"\n\n    shell_tool = ShellTool()  # Initialize the ShellTool instance\n\n    container_name = \"ubuntu24\"\n\n    # Combine the docker execution command with each provided command\n    docker_commands = [\n        f'docker exec {container_name} bash -c \"{command}\"' for command in commands\n    ]\n\n    # Run the commands sequentially\n    outputs = []\n    for docker_command in docker_commands:\n        output = shell_tool.run({\"commands\": [docker_command]})\n        outputs.append(output)\n        print(output)  # Optional: Log each command's output\n\n    return outputs  # Return the output of all commands\n</code></pre>"},{"location":"tools/shell_docker.html#docker-compose-configuration","title":"Docker Compose Configuration","text":"<p>The project uses Docker Compose to manage the containerized environment. Below is the configuration:</p> <pre><code>version: \"3\"\nservices:\n  ubuntu24:\n    image: ubuntu:24.04\n    container_name: ubuntu24\n    command: tail -f /dev/null\n</code></pre> <p>This configuration sets up an Ubuntu 24.04 container named \"ubuntu24\" that runs continuously, allowing for command execution using the <code>shell_docker</code>.</p>"},{"location":"tools/shell_local.html","title":"Shell Local","text":""},{"location":"tools/shell_local.html#shell_local","title":"shell_local","text":"<p>The <code>shell_local</code> is a function that allows running shell commands. It accepts a list of strings, where each string represents a command to be executed.</p>"},{"location":"tools/shell_local.html#parameters","title":"Parameters","text":"<ul> <li><code>commands</code>: A list of strings, each representing a shell command to be executed.</li> </ul>"},{"location":"tools/shell_local.html#usage","title":"Usage","text":"<pre><code>@tool\ndef shell_local(commands: list[str]):\n    \"\"\"Run a shell commands. Commands is a list of strings, each representing a command to run. Avoid interactive commands.\"\"\"\n    shell_tool = ShellTool()\n    output = shell_tool.run({\"commands\": commands})\n    print(output)\n    return output\n</code></pre>"},{"location":"tools/tools.html","title":"Tools Documentation","text":""},{"location":"tools/tools.html#table-of-contents","title":"Table of Contents","text":"<ul> <li>Shell Local Commands - Run shell commands locally</li> <li>Shell Docker Commands - Run shell commands in Docker containers</li> </ul>"}]}